# **Endless Run**

## INTRODUCTION

####**Endless Run**

[Endless Run](http://appadvice.com/appguides/show/endless-running) style games come in many variations, but the concept behind each of them is the same: run until you die. Over the years, the Endless Run has taken many different forms, from the continual horizontally-moving Sonic the Hedgehog franchise to the Temple Run series, which essentially did nothing more than change the camera angle. Even [Flappy Bird](https://techlab.education/java/flappy-bird/#flappy-bird) is an Endless Run game; you are in perpetual movement towards the right side of the screen, and you dodge pipes until you hit one and lose.

(((INSERT IMAGE OF COMPLETED GAME HERE)))

In this lab, you will create a version of the Endless Run game, in which you must avoid a constant stream of obstacles coming your way. The trickiest idea presented in this game is the use of an _extendable class_. It might seem confusing at first, but it will ultimately make things a lot easier by allowing us to efficiently create many different types of obstacles.

####**A bit of background...**

To construct this game, we will use the [Model-View-Controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) (MVC) architectural pattern to organize our JFrame application. MVC architecture is nothing more than a useful framework used by many to design graphical user interfaces (GUIs) and web applications. It divides a software application into three parts — model, view, and controller — which represent the different ways in which information is presented to and received from the user.

* The _controller_ is the component that takes user input and communicates it with the model and view. The controller and the view together are more or less what software engineers refer to as the “frontend.” This is where we will implement Key Listeners so that we can move the character.
* The _model_ manages the data and information that the application uses. It is basically what software engineers like to call the “backend.” This is where we will store and keep track of the objects that we use in the application.
* The _view_ is, as its name suggests, the visual and graphical portion of the application, which displays the information to the user in a helpful way. This is the component where we will use a JFrame to draw the graphics.


## PART I: CREATE A MOVEABLE CHARACTER IN JFRAME

####**Getting started**

Create a new package called `endless_run`, and inside create three new classes: `EndlessRunModel`, `EndlessRunView`, and `EndlessRunController`. Check the `public static void main(String[] args)` box only for `EndlessRunController`, and change `EndlessRunView` to extend JFrame (as shown below).

```java
import javax.swing.JFrame;

public class EndlessRunView extends JFrame {
    // Auto-generated by Eclipse to deal with serialization
    // Yours may look slightly different
    private static final long serialVersionUID = 1L;
}
```
*Note: If Eclipse tells you to import something — like it told me to “Import 'JFrame' (javax.swing)” — assume that it is correct and do as it says.*

Tell the controller to start up the application by declaring a new instance of itself.

```java
public class EndlessRunController {
    // Start application by creating a new instance of the controller
    public static void main(String[] args) {
        new EndlessRunController();
    }
}
```

####**Set up the communication lines**

In your controller, create global instances of your model and view classes, calling them `model` and `view`, respectively. Next, initialize them in the controller's constructor, passing them each the parameter `this`. This (no pun intended) will pass the constructors of the model and view each a reference to the controller, which will be essential for communication between the three components. In addition, create a global instance of `EndlessRunController`, called `controller`, in each of the model and view classes.

```java
public class EndlessRunController {
    // Create instances of the model and view classes
    EndlessRunModel model;
    EndlessRunView view;
    
    // Start application by creating a new instance of the controller
    public static void main(String[] args) {
        new EndlessRunController();
    }
    
    public EndlessRunController() {
        // Initialize the model and view objects
        model = new EndlessRunModel(this);
        view = new EndlessRunView(this);
    }
}
```

Since we passed the controller as a parameter to the model and view classes, then we must also edit their constructors to reflect this.

```java
public class EndlessRunModel {
    // Create instance of the controller class
    EndlessRunController controller;
    
    public EndlessRunModel(EndlessRunController controller) {
        // Initialize the controller variable to be the same as
        // the one passed in from the controller itself
        this.controller = controller;
    }
}
```

*Note: We only show `EndlessRunModel.java` here, but do the same in `EndlessRunView.java`.*

You will notice that in addition to taking the parameter `EndlessRunController controller`, the constructor contains the line `this.controller = controller`. Without this line, the controller variable declared outside of the constructor would be completely separate from the one passed into the constructor. This line of code connects the two, so that the model class and the controller class can now communicate directly with each other. Make sure that this line appears in both the model and the view classes. Your MVC architecture is now complete and ready for use!

####**Initialize the JFrame**

In the constructor of `EndlessRunView.java`, set the size of the application to width = 1200, height = 600. Next, set the visibility to true, so that the window actually shows up.

```java
// Initialize the JFrame
setSize(1200, 600);
setVisible(true);
```

Now, if you run the program from `EndlessRunController.java`, you should get a blank window.

####**Draw a circle**

In your view component, make a method called `public void paint(Graphics g)`. `Graphics` is a default Java class used for drawing on JFrames; it is called once automatically when you first open the JFrame, and afterwards can be called by using the default method `repaint()`.

*Note: The `Graphics` class works differently from the `Window` library ([apcs.io/java/Window.java](http://apcs.io/java/Window.java)) used in many Techlab tutorials. When drawing shapes, the (x, y) coordinates that you input are not the center of the shape, but rather the upper-left corner. Even for ovals (and thus circles, since a circle is a type of oval), the (x, y) represents the upper-left corner of the box that perfectly contains the oval, and instead of inputting a radius, you input the width and height of that box.*

(((INSERT PICTURE OF JFRAME MEASUREMENTS HERE. SHOW A RECTANGLE AND A CIRCLE.)))

First things first. Let's draw a red circle on a green background. Set the paint color by calling the graphics method `g.``setColor(color)`, passing in `Color.green` as its parameter. Next, draw the background by calling `g.fillRect(x, y, width, heigth)`, passing in the dimensions of the entire screen as its parameters. Then, change the paint color again, this time to red. Finally, draw a circle in the center of the JFrame with `g.fillOval(x, y, width, height)`.

```java
public void paint(Graphics g) {
    // Green background
    g.setColor(Color.green);
    g.fillRect(0, 0, 1200, 600);
    
    // Red circle for Player
    g.setColor(Color.red);
    g.fillOval(600 - 20, 300 - 20, 40, 40);
}
```

You will notice that for x and y, we entered the coordinates for center of the screen (600, 300) minus 20. This is because we put the dimensions of the circle as width = 40, height = 40, so we have to offset the upper-left corner of the circle-box by half of that width to center it.

If you run your code now, you should see a red circle in the center of a green screen. The circle will eventually be your character.

![draw circle](https://github.com/michaelschung/techlab/blob/master/Java/EndlessRun/draw_circle.png?raw=true)

These are the basics of drawing on a JFrame. However, we currently have no way to move this circle. This is a rather large problem, since the whole point of the game is to dodge things. Let's fix this.

####**Create a Player object**

Remember when we talked about MVC architecture? The model is the component that keeps track of the data and objects. So instead of drawing a random circle, let's make a Player class, declare an instance of it in `EndlessRunModel.java`, and use that to draw the circle instead. This way, we can edit the Player class later to add properties like score, health, etc.

Create a new class called `Player`, that has the variables `x` and `y`. Initialize these in the constructor to place the character in the center of the screen. So for now, this is all that you need in the Player class:

```java
public class Player {
    // Coordinates of the player
    int x;
    int y;
    
    public Player() {
        // Start in the center (600 - radius, 300 - radius)
        x = 580;
        y = 280;
    }
}
```

Next, the player needs a way to move. Let's declare four constants in our Player class, called `LEFT`, `RIGHT`, `UP`, and `DOWN`. Each of these should be an int, and they will determine which direction the player should move.

```java
// Constants to determine which direction to move
public static final int LEFT = 1;
public static final int RIGHT = 2;
public static final int UP = 3;
public static final int DOWN = 4;
```

Now we need to make a public method called `move(int direction)` method, which will be called from the controller when we want the player to move. The method takes in an integer parameter to determine the direction in which the controller has told it to move. We will compare this parameter to the four constants we created, and move the player accordingly.

```java
// Determine which direction to move
public void move(int direction) {
    if(direction == LEFT) {
        x -= 5;
    }
    if(direction == RIGHT) {
        x += 5;
    }
    if(direction == UP) {
        y -= 5;
    }
    if(direction == DOWN) {
        y += 5;
    }
}
```

Finally, we need to declare and initialize a Player object in `EndlessRunModel.java`, called `player`. Your model class should now look like this:

```java
public class EndlessRunModel {
    // Create instance of the controller class
    EndlessRunController controller;
    
    // Create a Player object
    Player player;

    public EndlessRunModel(EndlessRunController controller) {
        // Initialize the controller variable to be the same as
        // the one passed in from the controller itself
        this.controller = controller;
        
        // Initialize the Player object
        player = new Player();
    }
}
```

####**Access and draw the Player object from the view component**

Our next step is to draw the Player object in the view component. However, we currently do not have a direct connection between the model and view components, so we must access the Player object through the mutual controller.

In the controller, create a method called `getPlayer()` that returns the Player object. Since the Player object is in the model component, we have to use `model.player` to get hold of it in the controller.

```java
// Use this to access the Player object from the view component
public Player getPlayer() {
    return model.player;
}
```

Now, we can access the Player object contained in the model by going through the controller. So in the `paint(Graphics g)` method of the view component, use the `getPlayer()` method to make a new Player object from which to grab the `x` and `y` coordinates. Then, replace the `x` and `y` coordinates of the oval with `p.x` and `p.y`.

```java
public void paint(Graphics g) {
    // Green background
    g.setColor(Color.green);
    g.fillRect(0, 0, 1200, 600);
    
    // Red circle for Player
    Player p = controller.getPlayer();
    g.setColor(Color.red);
    g.fillOval(p.x, p.y, 40, 40);
}
```

If you run the program now, it should look exactly the same as the last time. The difference is that this time, the coordinates are coming directly from the Player object.

####**Add KeyListener to controller**

To move the player, we need to use something called a KeyListener. This is a default Java interface that receives keyboard events. Add `KeyListener` to the controller by editing the class declaration line to say the following:

```java
public class EndlessRunController implements KeyListener {
```

Eclipse will ask you to first import the KeyListener class, and then it will ask you to “add unimplemented methods.” When you do so, it will auto-generate three public methods: `keyTyped(KeyEvent e)`, `keyPressed(KeyEvent e)`, and `keyReleased(KeyEvent e)`. These are three methods that you must have in your code, even if you don't use them all. As their names suggest, `keyPressed()` is called when a key is pressed,` keyReleased()` is called when a key is released, and `keyTyped()` is called when a single key is pressed and then released. As you may guess, there is some overlap between these, but we will not discuss that here. We will not be using `keyTyped()` in this application, so you can just leave it blank.

You may be wondering what the parameter `KeyEvent e` means, and what it is for. Basically, whenever a keyboard event occurs, it sends a KeyEvent object with information about which key was involved. We use this object to process the keyboard event and determine what to do with it.

Examine the following code for processing an event where the “D” key is pressed:

```java
public void keyPressed(KeyEvent e) {
    if(e.getKeyCode() == KeyEvent.VK_D) {
        System.out.println("You pressed an D.");
    }
}
```

The expression `e.getKeyCode` takes the KeyEvent object `e` and returns the key code that it contains, which will tell us which key was pressed. (For letters and numbers, `getKeyCode()` simply returns the ASCII value of the character.) `VK_D` is a constant defined by the KeyEvent class to represent the “D” key. There is a “VK_” constant for every key on the keyboard.

At this point, there is only one more thing we have to do for the KeyListener to work. The controller implements KeyListener, but we also need to call the `addKeyListener()` method, passing in the controller, to register the class with the controller component. We cannot do this from inside the controller itself, so we will instead add it from the view component, using the reference to the controller that we passed in earlier. You should add the following code into your view's constructor, right before initializing the JFrame:

```java
// Add a KeyListener to the controller
addKeyListener(controller);
```

Now, if you run the application, you should get a message in your console every time you press the “D” key.

####**Move the player**

Of course, we don't actually want to use the “D” key. Instead of processing a “D” press, we need to process the arrow keys. This is as easy as changing `VK_D` to `VK_LEFT`, and replacing the print line with `model.player.move(Player.LEFT)`. Since `LEFT` is a static variable in the Player class, we can access it from the controller to pass as the direction in the `move()` method. The first one should look like this; try to do the other three arrow keys by yourself.

```java
public void keyPressed(KeyEvent e) {
    // Process arrow key presses
    if(e.getKeyCode() == KeyEvent.VK_LEFT) {
        model.player.move(Player.LEFT);
    }
    // Do the other three arrow keys, following the pattern of the first
}
```

BUT WAIT! This code will not actually work just yet! Remember that when we said that to refresh the JFrame, you have to call the `repaint()` method. So, at the bottom of the `keyPressed()` method, after the closing bracket of the last if-statement, write a `view.repaint()`. This way, the JFrame will refresh every time you press a key. Your code should now look like this:

```java
public void keyPressed(KeyEvent e) {
    // Process arrow key presses
    if(e.getKeyCode() == KeyEvent.VK_LEFT) {
        model.player.move(Player.LEFT);
    }
    if(e.getKeyCode() == KeyEvent.VK_RIGHT) {
        model.player.move(Player.RIGHT);
    }
    if(e.getKeyCode() == KeyEvent.VK_UP) {
        model.player.move(Player.UP);
    }
    if(e.getKeyCode() == KeyEvent.VK_DOWN) {
        model.player.move(Player.DOWN);
    }
    // Refresh the JFrame
    view.repaint();
}
```

At this point, run the application and make sure you can move the circle.

![moving ball](https://github.com/michaelschung/techlab/blob/master/Java/EndlessRun/moving_ball.gif?raw=true)

####**Refreshing with a Timer**

We can now refresh the screen to move our circle, but we have a problem: if the screen only refreshes when the player is moving, then the game won't be very much fun. It would basically end up being played one frame at a time, and the player would have as much time as they want to make each move, because none of the obstacles would move unless the player moved. We will fix this problem by changing the placement of the `view.repaint()` method. Instead of refreshing the screen every time the player moves, we want the screen to automatically refresh at regular intervals. This way, the obstacles will continue to move toward the player, whether or not the player is choosing to move at any given moment.

To accomplish this goal, we will use a `Timer` and `TimerTask` classes, and use them to tell our program to refresh the screen at a chosen interval.

In the constructor of the controller class, after initializing the model and view components, create a new `Timer` object (you will have to import the `Timer` class):

```java
// Create a Timer object
Timer t = new Timer();
```

Now, create a `TimerTask` object called `myTask`, which will be used to define what exactly we want to happen during each refresh.

```java
// Create a TimerTask object
TimerTask myTask = new TimerTask() {

};
```

This may look strange, but it is nothing more than declaring a `TimerTask` object and defining some of its attributes in one line. The line begins with `TimerTask myTask` and ends with `};`, but we split it up into multiple lines to make it easier to read. The method we need to define is called an *abstract* method.

At this point, you should have a red line under `TimerTask()`. If you hover, it will tell you that you “must implement the inherited abstract method TimerTask.run().” Click “add unimplemented methods,” and it should add a `public void run()` method. This method is the body of what the `TimerTask` will do. We want it to refresh the JFrame, so we will type in `view.repaint()`. Your code should now look like this (we cleaned ours up a bit by taking out the `@Override` and the `TODO` comment):

```java
TimerTask myTask = new TimerTask() {
    // This is the task to be done
    public void run() {
        view.repaint();
    }
};
```

Now, we need to call our `Timer` object `t`'s method `scheduleAtFixedRate(task, delay, period)`. This method takes three parameters: `task` is what needs to be done, `delay` is the amount of time before the first instance of the task, and `period` is the amount of time between each successive task. We have already created a task, so replace `task` with `myTask`. We want our task to begin immediately, so `delay` is 0. Finally, we will replace `period` with 50.

```java
// Schedule the TimerTask to be done every 50 ms, starting immediately
t.scheduleAtFixedRate(myTask, 0, 50);
```

The code for this whole section (`Timer` + `TimerTask`) should now look like this:

```java
// Create a Timer object
Timer t = new Timer();
// Create a TimerTask object
TimerTask myTask = new TimerTask() {
    // This is the task to be done
    public void run() {
        view.repaint();
    }
};
// Schedule the TimerTask to be done every 50 ms, starting immediately
t.scheduleAtFixedRate(myTask, 0, 50);
```

So now, after all this, we can finally remove the `view.repaint()` line from our `keyPressed()` method, and put it instead into here. **Do not forget to remove `view.repaint()` from `keyPressed()`.** Your final code for this entire section (the `Timer` and `TimerTask` objects) should look like this:

If you run the application at this point, it will work just like before. The difference is that this time, the screen is actually refreshing constantly, whether or not you are moving the circle. You can't see the difference since there are no obstacles yet, but we promise that this is the better way to do it. Trust us on this one.

####**~CHECKPOINT #1~**

This is all of the code we have written so far (excluding the import statements at the top of each file, and `Player.java`, which is shown in full in the section “Create a Player object”). Please double check your code, paying close attention to indentation, capitalization, and syntax. If you have any errors, here is your chance to catch them!

```java
public class EndlessRunModel {
    // Create instance of the controller class
    EndlessRunController controller;
    
    // Create a Player object
    Player player;

    public EndlessRunModel(EndlessRunController controller) {
        // Initialize the controller variable to be the same as
        // the one passed in from the controller itself
        this.controller = controller;
        
        // Initialize the Player object
        player = new Player();
    }
}
```

```java
public class EndlessRunView extends JFrame {
    // Auto-generated by Eclipse to deal with serialization
    // Yours may look slightly different
    private static final long serialVersionUID = 1L;
    
    // Create instance of the controller class
    EndlessRunController controller;

    public EndlessRunView(EndlessRunController controller) {
        // Initialize the controller variable to be the same as
        // the one passed in from the controller itself
        this.controller = controller;
        
        // Add a KeyListener to the controller
        addKeyListener(controller);
        
        // Initialize the JFrame
        setSize(1200, 600);
        setVisible(true);
    }
    
    public void paint(Graphics g) {
        // Green background
        g.setColor(Color.green);
        g.fillRect(0, 0, 1200, 600);
        
        // Red circle for Player
        Player p = controller.getPlayer();
        g.setColor(Color.red);
        g.fillOval(p.x, p.y, 40, 40);
    }
}
```

```java
public class EndlessRunController implements KeyListener {
    // Create instances of the model and view classes
    EndlessRunModel model;
    EndlessRunView view;

    // Start application by creating a new instance of the controller
    public static void main(String[] args) {
        new EndlessRunController();
    }

    public EndlessRunController() {
        // Initialize the model and view objects
        model = new EndlessRunModel(this);
        view = new EndlessRunView(this);
        
        // Create a Timer object
        Timer t = new Timer();
        // Create a TimerTask object
        TimerTask myTask = new TimerTask() {
            // This is the task to be done
            public void run() {
                view.repaint();
            }
        };
        // Schedule the TimerTask to be done every 50 ms, starting immediately
        t.scheduleAtFixedRate(myTask, 0, 50);
    }
    
    // Use this to access the Player object from the view component
    public Player getPlayer() {
        return model.player;
    }

    public void keyTyped(KeyEvent e) {
        // Not using this method, so just leave it empty
    }
    
    public void keyPressed(KeyEvent e) {
        // Process arrow key presses
        if(e.getKeyCode() == KeyEvent.VK_LEFT) {
            model.player.move(Player.LEFT);
        }
        if(e.getKeyCode() == KeyEvent.VK_RIGHT) {
            model.player.move(Player.RIGHT);
        }
        if(e.getKeyCode() == KeyEvent.VK_UP) {
            model.player.move(Player.UP);
        }
        if(e.getKeyCode() == KeyEvent.VK_DOWN) {
            model.player.move(Player.DOWN);
        }
    }
    
    public void keyReleased(KeyEvent e) {
        
    }
}
```

Once you are sure everything is correct, give yourself a good long break! We've thrown a lot of information at you, so go outside, get some fresh air, and relax your eyes from the computer screen. When you're ready, come back to continue!


## PART II: CREATING AND MOVING OBSTACLES

####**Smoothing the movement**

Okay, we lied a little bit. There is a small problem in the player movement that we still want to improve, so we are going to fix that before moving onto the obstacles. We just wanted to make sure that your brain didn't explode from all the information in the last section.

You may have noticed that the player currently moves in jerky increments, rather than in a continuous smooth motion. This happens because a pressed key sends KeyEvents at a fixed rate, which is slower than the 50 millisecond refresh rate of the screen. So instead of moving every time a KeyEvent is sent, we will move as long as a boolean to move is `true`. We will need a boolean for each direction.

For example, if we press the left arrow key, the boolean for “left” will be set to `true`.  This way, every time the screen refreshes, it will check if the boolean for “left” is `true`, and move the player if it is. The boolean for “left” will only be set to `false` when the left arrow key is released. So the player will continue to move left smoothly as long as the left arrow key is held down. Of course, you need to do this for all four directions, not just left.

Declare four booleans at the top of the controller, called `left`, `right`, `up`, and `down`. In the constructor, initialize all of these to `false`, since you should not be moving when the game starts.

```java
public class EndlessRunController implements KeyListener {
    // Create instances of the model and view classes
    ...
    
    // Booleans to check directions
    boolean left, right, up, down;
    
    // Start application by creating a new instance of the controller
    ...
    
    public EndlessRunController() {
        // Initialize the model and view objects
        ...
        
        // Initially not moving anywhere
        left = false;
        right = false;
        up = false;
        down = false;
```

Next, edit the `keyPressed()` method so that instead of directly changing the x and y coordinates of the player, you simply set the appropriate directional boolean to `true`.

```java
public void keyPressed(KeyEvent e) {
    // Process arrow key presses
    if(e.getKeyCode() == KeyEvent.VK_LEFT) {
        left = true;
    }
    // do the rest yourself
}
```

Remember that we will need to stop moving in a given direction when we release the arrow key in that direction. To do this, copy all of the code from `keyPressed()` into `keyReleased()`, but change all of the `true`'s to `false`'s.

```java
public void keyReleased(KeyEvent e) {
    // Process arrow key presses
    if(e.getKeyCode() == KeyEvent.VK_LEFT) {
        left = false;
    }
    // do the rest yourself
}
```

So now that we've changed our code to use booleans, we need to make a method that checks them every frame and moves the player accordingly.

In the controller, make a private method called `movePlayer()`. This method will check the direction booleans and move the player according to which ones (if any) are true. Write the code so that every run of the method will check each direction boolean independently of the others, since we want the player to be able to move diagonally if they want to.

```java
private void movePlayer() {
    if(left) {
        model.player.move(Player.LEFT);
    }
    // do the rest yourself
}
```

Finally, we need to call `movePlayer()` every time we refresh the screen, so add a method call in the `run()` method of the `TimerTask` back in the constructor, just before the `view.repaint()`.

If you run your program now, the player should move around much more smoothly.

![smooth ball movement](https://github.com/michaelschung/techlab/blob/master/Java/EndlessRun/smooth_ball_movement.gif?raw=true)

####**Creating obstacles**

Alright, now it's actually time to move onto obstacles.

Let's take a moment to plan out our plan of attack. We will have three types of obstacles: Foxes, Alligators, and Stumps. They will all look different, but they will all move in the exact same way — moving across the screen from right to left — even if they do so at different speeds. They will also inflict damage in the same way, though some will be more powerful than others. What do you think would be the best (a.k.a. most efficient) way to create these obstacles?

*Sounds like a job for **extendable classes**!*

(If you don't remember how extendable classes work, refresh your memory here: [(((((((INSERT LINK TO TUTORIAL HERE))))))](http://jkalsdjfalskjf/))

Let's start by making the general class that each different type of obstacle will extend. Let's call it `Obstacle`.

```java
public class Obstacle {
    
}
```

Every obstacle needs a location on the screen (`x` and `y` coordinates), size (`width` and `height`), `speed`, `damage`, and `color`. Let's create variables for each of those attributes.

```java
// These are the variables that every obstacle will have
int x;
int y;
int width;
int height;
int speed;
int damage;        // amount of damage to inflict on player
Color color;
```

*Note: The `Color` class must be imported (`java.awt.Color`) to use. See the [Java documentation](https://docs.oracle.com/javase/7/docs/api/?java/awt/Color.html) for usage.*

Next, we need a way for every obstacle to move across the screen. They will all move at different speeds, but in the same way: from right to left. So let's make a public method called `move()`. Inside this method, we just need one line of code, which moves the obstacle towards the left of the screen at the rate of `speed` pixels per frame.

```java
// Move the obstacle towards the left side of the screen
public void move() {
    x -= speed;
}
```

Now, let's make a constructor. Think about which of the obstacle's attributes (`x`, `y`, `width`, `height`, `speed`, `damage`, `color`) should be declared in this constructor, and which ones should be left up to the child constructors (which we will get to soon).

When we thought about it, we decided that everything except for the variables `x` and `y` should be declared in the child constructor, since those are all attributes that are specific to which type of obstacle it is. For example, a Fox will be smaller and faster than a Stump, so the `width`, `height`, and `speed` dimensions will be different. A Stump, however, will inflict more damage if you run into it, so `damage` will be greater. Each type of obstacle will have a its own specific `color`.

The variables for `x` and `y`, however, are different. The initial `x` value will be initialized in the parent constructor as follows:

```java
// Parent constructor
public Obstacle() {
    // Initialize x to be a random point off the right side of the screen
    x = (int) (Math.ceil(Math.random() * 1200)) + 1200;
}
```

`Math.random()` returns a random double between 0 (inclusive) and 1 (exclusive). Multiplying this by 1200 will give us a number between 0 and 1200. We cast the value as an integer, since `x` is an integer. So far, this would place our `x` value anywhere on the screen. However, we want all of our obstacles to spawn offscreen and then move towards us, so we add another 1200. Now, the closest any of them can spawn is at 1200 — that is, exactly offscreen.

The initial `y` value is dependent on the height of the obstacle. Note that `height` may vary between obstacles, but the `y` value will always be between 0 and the height of the JFrame minus `height`. Thus, since `y` will always be calculated in the exact same way for every obstacle, we want to do it in the parent constructor. The only problem is that `height` will be initialized in the child constructor, which executes *after* the parent constructor. So at the point of declaring `y`, our `height` variable will not yet have been initialized.

Our solution to this is to declare another public method in the Obstacle class, one which will only be called once as part of the initialization. We will call it `init()`, which is short for “initialize.” Inside `init()`, we will declare our `y` variable to be equal to a random integer between 0 and 600 - height (the height of our JFrame minus the height of our obstacle).

```java
// Some variables must be initialized after the child constructor runs
public void init() {
    y = (int) (Math.random() * (600 - height));
}
```

The only problem with this is that our window is not actually 600 pixels tall. The JFrame is, but our playing space is not. In a JFrame application, the toolbar on top (the one with the “close,” “minimize,” and “maximize” buttons) takes exactly 22 pixels. So we actually want our random integer to be generated between 0 and 600 - `height` - 22, and then add 22 to whatever comes out. This way, our new obstacle can start at any y-value that will keep it completely on the screen. Change the declaration line to resemble the following:

```java
y = (int) (Math.random() * (600 - height - 22)) + 22;
```

We will call the `init()` method at the end of the child constructor, after everything else has been initialized.

####**Different types of obstacles**

Now that we have the general Obstacle class, we need to create child classes for specific types of Obstacles, each of which extends the original Obstacle class.

First, let's create the Stump class, along with its constructor:

```java
public class Stump extends Obstacle {
    // Initialize Obstacle variables to be specific to Stump
    public Stump() {
        
    }
}
```

Remember, the very first thing we need to do in our child constructor is call the parent constructor. We do this by calling the command `super();`. Next, we will initialize all of the variables (except `x` and `y`) to be specific to a Stump. Pay attention to the color declaration. The three numbers (in this case 100, 50, and 0) are the red, green, and blue (RGB) values of the color that we want. If you don't know how RGB values work, see [here](https://en.wikipedia.org/wiki/RGB_color_model).

```java
width = 60;
height = 50;
speed = 4;          // slow,
damage = 10;        // but strong
color = new Color(100, 50, 0);   // see Java documentation
```

Finally, we will call the `init()` method in the parent class with the command `super.init();`. Your Stump constructor should look like this:

```java
public Stump() {
    super();
    width = 60;
    height = 50;
    speed = 4;          // slow,
    damage = 10;        // but strong
    color = new Color(100, 50, 0);   // see Java documentation
    super.init();
}
```

And that's it for the Stump class! The process is made extremely simple through the use of an extendable class.

Now, on your own, create the Fox and Alligator classes. Set their values as per the chart below. Notice that the color for the Fox is in a different format. The Color class has some preset colors, which you can access by calling `Color.<color>` (replacing `<color>` with the desired color). We want our Fox to be orange, so we will call `Color.orange`.

*Note: For a full list of preset color values, see the [Java documentation for the Color class](https://docs.oracle.com/javase/7/docs/api/java/awt/Color.html).*

|       || Fox          | Alligator   |
|:-------|:------------ |:------------|
| width  | 40           | 100         |
| height | 30           | 40          |
| speed  | 12           | 8           |
| damage | 2            | 5           |
| color  | Color.orange | (40, 80, 0) |

Wasn't that easy? This is the beauty of extendable classes.

####**Move a Fox object**

We will eventually have a whole bunch of obstacles on the screen at once, but first, let's try to move just one single Fox.

We start by declaring and initializing a Fox object in our Model component (remember again that our Model component is the one where we declare and store references to all of our objects).

```java
...

Player player;
Fox fox;        // this is new code

public EndlessRunModel(EndlessRunController controller) {
    ...
    
    player = new Player();
    
    // Initialize the Fox object - this is new code
    fox = new Fox();
}
```

To draw the Fox, we will go back to our View component. Everything that we need to draw the Fox (location, dimensions, color) is contained in the Fox object itself, so we will use those values in our `paint(Graphics g)` method. To access the Fox object that we declared in the model, we must call it through our controller, which we have linked up to our view.

```java
public void paint(Graphics g) {
    ...
    
    // Draw the Fox
    Fox f = controller.model.fox;
    g.setColor(f.color);
    g.fillRect(f.x, f.y, f.width, f.height);
}
```

At this point, we can run our code, but we won't see the Fox. Why? Because we told it to spawn offscreen, and we haven't yet told it to move. So let's add movement. Recall that when we wanted the player to move, we had to call our `movePlayer()` method every time we refresh the screen. So now, we just need to include a call to our Fox's `move()` method (which is actually just the general `move()` method for all Obstacles). So in our Controller component, edit the TimerTask to include a call to `model.fox.move()`.

```java
TimerTask myTask = new TimerTask() {
    // This is the task to be done
    public void run() {
        movePlayer();
        model.fox.move();
        view.repaint();
    }
};
```

Now, if you run your code, you should see something like the following. Congratulations, you have a moving object!

![moving fox](https://github.com/michaelschung/techlab/blob/master/Java/EndlessRun/moving_fox.gif?raw=true)

*Note: Your Fox will most likely show up in a different spot, and it may take a shorter or longer amount of time to appear on screen. This is because we randomized its starting position, so it may start just barely offscreen or an entire extra screen away.*

####**Create multiple moving Foxes**

*Note: this section is meant to explain a concept before expanding it out to a larger context. As such, all of the code written in this section will be changed shortly after we write it. Just warning you, so don't get too attached!*

The eventual goal is to create a randomized assortment of Obstacles of all types, but for now, let's just start with a set of Fox objects.

We want to create and move multiple Foxes at a time, so let's go back to our our Model class and make an ArrayList to hold them. Also, delete the declaration and initialization of the Fox object that we created in the previous section.

```java
// Create ArrayList to hold Foxes
ArrayList<Fox> foxList = new ArrayList<Fox>();
```

In the constructor of your Model class, run a for loop to fill your ArrayList with five Fox objects.

```java
// Add 5 Fox objects to the ArrayList
for(int i = 0; i < 5; i++) {
    Fox f = new Fox();
    foxList.add(f);
}
```

Next, go to the Controller class. Delete the line `model.fox.move();` in the TimerTask, since `model.fox` no longer exists. Create a public method `getFoxes()` that returns `foxList`. We will use this method to access `foxList` from the View component.

```java
// Use this to access the Fox objects from the view component
public ArrayList<Fox> getFoxes() {
    return model.foxList;
}
```

In order for our Fox objects to move, we need to iterate through `foxList` and move each one individually. But instead of creating a for loop inside our TimerTask, let's put the loop inside a separate method.

```java
// Use this to move all of the Fox objects in model.foxList
public void moveFoxes() {
    for(Fox f : model.foxList) {
        f.move();
    }
}
```

Then, add a call to `moveFoxes()` in the TimerTask `run()` method, right before the `view.repaint()`.

Finally, we need to draw our foxes. Go to the View component, and delete the code to draw a single Fox. Then, pull `foxList` from the Model using our Controller's `getFoxes()` method.

```java
// Get the Fox objects in order to draw them
ArrayList<Fox> foxes = controller.getFoxes();
```

Draw the Fox objects by iterating through the ArrayList and drawing each one individually.

```java
for(Fox f : foxes) {
    g.setColor(f.color);
    g.fillRect(f.x, f.y, f.width, f.height);
}
```

Run your code now, and you should see five Fox objects move across the screen.

####**Obstacle wrap-around**

Before moving on, we need to address a certain issue. Currently, our five foxes move across the screen and never come back; we want to have an endless stream of Foxes. We could continually add more and more Foxes, but that would very quickly take over our computer's memory and slow everything down. Instead, we will give the illusion of an endless stream by resetting the position of each Fox object when it goes off the screen.

To do this, we need to make a quick change to `move()` method in our Obstacle class (remember, the Fox class uses the `move()` method from the Obstacle class). Add a conditional statement to check if the Obstacle has moved completely off the screen, and reset its position if it has.

```java
// Reset position if the obstacle goes offscreen
if(x < -width) {
    x = (int) (Math.random() * 1200) + 1200;
    y = (int) (Math.random() * (600 - height - 22)) + 22;
}
```

Now, run your code again. The foxes will never stop coming.

![continuous foxes](https://github.com/michaelschung/techlab/blob/master/Java/EndlessRun/continuous_foxes.gif?raw=true)

####**More than just Foxes**

Now that we have Foxes moving, let's expand our code to include not just Foxes, but Stumps and Alligators as well.

Go back to the Model component, and change the declaration of the ArrayList to type `Obstacle`, and call it `obstacles`.

```java
// Create ArrayList to hold Obstacles
ArrayList<Obstacle> obstacles = new ArrayList<Obstacle>();
```

Now, delete the initialization of `foxList` in the constructor. Instead, we will initialize `obstacles` to be filled with roughly equal numbers of Stumps, Alligators, and Foxes.

Let's start with a total of ten Obstacles, so open a for loop that will run ten times. Inside the loop, declare a general Obstacle object, but don't initialize it yet. Also declare an `int` called `random` and initialize it to a random number between 0 and 3. This number will be used to determine which type of Obstacle to create.

```java
// Fill ArrayList with random types of Obstacles
for(int i = 0; i < 10; i++) {
    Obstacle newObstacle;
    int random = (int) (Math.random() * 3);
}
```

Next, write a series of conditionals that uses the value of `random` to determine which type of Obstacle `newObstacle` will be. Finally, after the conditionals, add `newObstacle` to `obstacles`.

Notice that even though `obstacles` is an ArrayList of type Obstacle, we are allowed to add Stumps, Alligators, and Foxes. This is one of the properties of extendable classes: all children classes can be placed into an ArrayList of the parent type.

```java
if(random == 0) {
    newObstacle = new Stump();
} else if(random == 1) {
    newObstacle = new Alligator();
} else {
    newObstacle = new Fox();
}
obstacles.add(newObstacle);
```

Now, go back to the Controller. You will notice that you have an error in the `moveFoxes()` and `getFoxes()` methods now. This is because our variable `foxList`, which they both refer to, no longer exists. Change the name and type of `getFoxes()`, and have it return `model.obstacles`.

```java
// Use this to access the Obstacles from the view component
public ArrayList<Obstacle> getObstacles() {
    return model.obstacles;
}
```

Change the name of `moveFoxes()` to `moveObstacles()`, and edit its content to move every Obstacle in `model.obstacles`.

```java
// Use this to move all of the Obstacle objects in model.obstacles
public void moveObstacles() {
    for(Obstacle o : model.obstacles) {
        o.move();
    }
}
```

Notice that we can refer to all of the objects in `obstacles` as Obstacle objects, because all of them -- Stump, Alligator, and Fox -- extend the Obstacle class. Also, as Obstacles they all share the same `move()` method, so they can all be moved in the exact same way.

The last thing we need to do in the Controller is to change the `moveFoxes();` line in our TimerTask to call `moveObstacles()` instead.

Finally, go back to the View component and edit the code to draw all Obstacles in `obstacles` instead of all Foxes in `foxList` (which doesn't even exist anymore).

```java
// Get the Obstacle objects in order to draw them
ArrayList<Obstacle> obstacles = controller.getObstacles();
for(Obstacle o : obstacles) {
    g.setColor(o.color);
    g.fillRect(o.x, o.y, o.width, o.height);
}
```

If you run your code now, you should see something like this:

![all obstacles](https://github.com/michaelschung/techlab/blob/master/Java/EndlessRun/all_obstacles.gif?raw=true)

####**~CHECKPOINT #2~**

